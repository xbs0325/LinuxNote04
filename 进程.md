[TOC]

## 1. 进程和程序

​	程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建、调度和消亡。程序是静态的，进程是动态的。

​	程序类似于剧本 而进程类似于正在出演的戏

​	在linux系统中，操作系统是通过进程去完成的一个一个的任务，**进程是管理事务的基本单元**

​	进程拥有自己独立的**处理环境**（如：当前需要用到哪些环境变量，程序运行的目录在哪，当前是哪个用户在运行此程序等）和**系统资源**（如：处理器CPU占用率、存储器、I/O设备、数据、程序）

公司相当于操作系统，部门相当于进程，公司通过部门来管理（系统通过进程管理），对于各个部门，每个部门都有各自的资源，如人员，电脑设备，打印机等。


## 2. 单道、多道程序设计（了解）

### 2.1 单道程序设计

​	所有进程一个一个排队执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现是必然的。所有这种模型在系统资源利用上极其不合理，在计算机发展历史上存在不久，大部分都被淘汰了

### 2.2 多道程序设计

​	在计算机内存中同时存放几道相互独立的程序，他们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保障

在多道程序设计模型中，多个进程轮流使用CPU（分时复用CPU资源）。而当下CPU为纳秒级，一秒可以执行大约10亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。



## 3. 并行和并发

**并行（parallel）**：指在同一时刻，有多条指令在多个处理器上同时执行

**并发（concurrency）**：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段是多个进程快速交替的执行。



## 4. MMU

MMU是Memory Management Unit的缩写，中文名是内存管理单元，他是中央处理器（CPU）中用来管理虚拟储存器、物理储存器的控制路线，同时也负责虚拟地址映射为物理地址，以及提供听见机制的内存访问权限，若用户多线程操作系统。

​		虚拟地址				物理地址

CPU---------------->MMU-------------->主存

​	^														|

​	|														|

​	|					    数据						|

​	 ——————<————<————



## 5. 进程控制块PCB

​	进程运行时，内核为进程每个进程分配一个**PCB（进程控制块）**，维护进程相关的信息，linux内核控制块是task_struct结构体。



在/usr/src/linux-hwe-xxx-headers-xxx/include/linux/sched.h文件中可以查看struct task_struct结构体定义

其内部成员有很多，我们掌握以下的部分即可：

* 进程id。系统中每个进程有唯一的id，在c语言中用pid_t类型表示，其实就是一个非负整数。
* 进程的状态，有就绪、运行、挂起、停止等状态。
* 进程切换时需要保存和恢复的一些CPU寄存器
* 描述虚拟地址空间的信息
* 表述控制终端的信息
* 当前工作目录（Current Working Directory）
* umask掩码
* 文件描述符表，包含很多指向file结构体的指针
* 和信息相关的信息
* 用户id和组id
* 会话（Seesion）和进程组。
* 进程可以使用的资源上限（Resource Limit）。





## 6. 进程的状态(重点)

三态模型中，进程状态分为**运行态，就绪态，阻塞态**。

五态模型中，进程分为**新建态，终止态，运行态，就绪态，阻塞态**。

![](.\五态模型.png)

## 7. 进程相关的命令

### 7.1 ps

process status

进程是一个具有一定独立功能的程序，他是操作系统动态执行的基本单元。

ps命令可以查看进程的详细状况，常用选项(选项可以不加" - ")如下: 

| 选项 | 含义                                     |
| ---- | ---------------------------------------- |
| -a   | 显示终端上的所有进程，包括其他用户的进程 |
| -u   | 显示进程的详细状态                       |
| -x   | 显示没有控制终端的进程                   |
| -w   | 显示加宽，以便显示更多信息               |
| -r   | 只显示正在运行的进程                     |

ps aux

ps ef

ps -a



### 7.2 top

top(table of processes)

类似windows中的任务管理器(一秒钟刷新一次)

| 按键 | 含义                               |
| ---- | ---------------------------------- |
| M    | 根据内存使用量来排序               |
| P    | 根据CPU占有率来排序                |
| T    | 根据进程运行时间的长短来排序       |
| U    | 可以根据后面输出的用户名来筛选进程 |
| K    | 可以根据后面输出的PID来杀死进程    |
| q    | 退出                               |
| h    | 获得帮助                           |

### 7.3 kill

格式: 

kill [-signal] pid


在Unix和Linux系统中，通常情况下，`kill` 命令使用信号编号来终止进程。标准的信号编号包括：

- `SIGHUP` (1) - 重启进程
- `SIGINT` (2) - 中断进程（通常由 Ctrl+C 触发）
- `SIGQUIT` (3) - 退出进程（通常由 Ctrl+\ 触发）
- `SIGKILL` (9) - 强制终止进程
- `SIGTERM` (15) - 正常终止进程

通常用于 `kill` 命令的信号编号是 1、2、3、9 和 15。

### 7.4 killall

用进程名杀死进程

`killall -9 sleep`

```
xbs@xbs-virtual-machine:~/mywork/++--$ sleep 3000 &
[1] 35120
xbs@xbs-virtual-machine:~/mywork/++--$ sleep 3000 &
[2] 35121
xbs@xbs-virtual-machine:~/mywork/++--$ sleep 3000 &
[3] 35122
xbs@xbs-virtual-machine:~/mywork/++--$ sleep 3000 &
[4] 35123
xbs@xbs-virtual-machine:~/mywork/++--$ killall sleep
[1]   已终止               sleep 3000
[2]   已终止               sleep 3000
[3]-  已终止               sleep 3000
[4]+  已终止               sleep 3000
```



## 8. 进程号和相关函数

每个进程都有一个进程号来标识，其类型为pid_t（整型），进程号的范围：0~32767.进程总是唯一的，但进程号可以重复使用。当一个进程终止后，其进程号就可以再次使用。

![](.\进程号.png)

三个不同的进程号

**进程号（PID）:**

​	标识进程的一个非负整型数。

**父进程号（PPID）:**

​	任何进程（除init进程）都是由另一个进程创建，该进程被称为创建进程的父进程（PPID）。如A进程创建了B进程，A的进程号就是B进程的父进程号。

**进程组号（PGID）:**

​	进程组号是一个或多个进程的集合。他们之间相互惯量，进程组可以接受同一终端的各种信号，关联的进程有一个进程组号（PGID）。这个过程类似于QQ群，组相当于QQ群，各个进程相当于各个好友，把各个好友都拉入一个QQ群里，主要是方便管理，特别是通知某些事时，只要在群里吼一声，所有人都会接收到，简单粗暴。但是，这个进程组号和QQ群是有点区别的，默认的情况下，当前的进程号会做当前的进程组号。

### 8.1 getpid函数

```
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
功能:
	获取本进程号（PID）
参数：
	无
返回值：
	本进程号
```



### 8.2 getppid函数

```
#include <sys/types.h>
#include <unistd.h>

pid_t getppid(void);
功能:
	获取调用此函数的进程的父进程号（PID）
参数：
	无
返回值：
	调用此函数的进程的父进程号
```



### 8.3 getpgid函数

```
#include <sys/types.h>
#include <unistd.h>

pid_t getpgid(pid_t pid);
功能:
	获取进程组号（PGID）
参数:
	pid:进程号
返回值:
	参数为0时返回当前进程组号，否则返回参数指定的进程组号
```



## 9. 子进程的创建

系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。

```
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
功能：
	用于从一个已存在的进程中创建一个新的进程，新进程称为子进程，原进程称为父进程。
参数：
	无
返回值：
	成功：子进程中返回0，父进程中返回子进程ID。pid_t，为整型。
	失败：返回-1
	失败的两个主要原因是：
		1）当前的进程数已经到到了系统规定的的上限，这时errno的值被设置为EAGAIN。
		2）系统内存不足，这时errono的值被设为了ENOMEM
```

示例代码：

```
int main()
{
        pid_t pid = -1;
        pid = fork();

        printf("hello,world\n");
        printf("fork() == %d\n",pid);
        if(pid == 0)
        {
                printf("这是子进程\n");
        }
        else
        {
                printf("这是主进程\n");
        }
        return 0;
}
```

运行结果如下：

```
hello,world
fork() == 36741
这是主进程
hello,world
fork() == 0
这是子进程
```

调用fork()后的子进程从fork()位置的下一条开始运行

(由pc指针找到子进程开始执行的位置)

##### 注：为什么在父进程中fork()的返回值是子进程ID？ 

原因：父线程中无获取子进程ID的函数(一个父可能对应多个子) 所以需要在创建时返回子进程ID6+

**为何子进程中不需要返回父进程ID而是返回0？**

子进程有获取父进程ID的函数`getppid()`。

返回0可以简便的区分父子进程

## 10. 父子进程的关系

读时共享 写时拷贝

解释：

​	创建进程时，进程信息被放在一个叫做进程控制块{PCB（process control block）}的数据结构中（linux中为task_struct）

​	创建子进程时 若子进程复制父进程的数据则会消耗大量时间与空间

​	所以在只读时父子进 程共享数据，只有写数据时才会拷贝出新的数据

图解：

![](.\读时共享，写时拷贝.png)

### 11.区分父子进程

依靠fork()函数返回值区分父子进程

在父进程中 fork()返回的是子进程ID （[返回值这样设定的原因](#注：为什么在父进程中fork()的返回值是子进程ID？ )）

在子进程中 fork()返回的是0

 

### 12. 父子进程地址空间

读时共享 写时拷贝

### 13. 父子进程堆空间

读时共享 写时拷贝

**注：Valgrind是一个用于内存分析、检测内存泄漏、查找内存错误等的强大工具**

可以使用`valgrind  ./a.out `

查看进程中有哪些空间没有被释放



### 14. GDB调试多进程

​	使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是子进程，默认跟踪父进程。

* set follow-fork-mode child 设置gdb在fork之后跟踪子进程

* set follow-fork-mode parent 设置跟踪父进程

  

  注意,一定要在fork函数调用前设置才有效
  
  

### 15. 进程退出函数

```
#include <stblib.h>
void exit(int status);

#include <unistd.h>
void _exit(int status);
功能:
	结束调用此函数的进程（直接退出不做任何清理）
参数：
	status：返回父进程的参数（低8位有效），至于这个参数
返回值：
	无
```

等价于stblib.h中的_Exit()

**问:何时使用？**

当数据发生不可逆转的损坏时，即不希望将数据存储到文件或数据库中时使用

直接强制退出程序，不进行任何保存。

**问:_exit与exit的区别?**

_exit

跳过了atexit注册的退出处理函数

跳过刷新I/O缓存（printf可能还未将缓存区刷新）

跳过关闭文件描述符



### 16. 等待子进程退出函数

#### 16.1 概述

​	在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件、占用的内存等。但是仍为其保留一定的信息，这些信息主要指进程控制块PCB的信息(包括进程号、退出状态、运行时间等)。

​	父进程可以通过调用wait或者waitpid得到他的退出状态同时彻底清除掉这个进程。

​	wait()和waitpid()函数的功能一样，区别在于，wait函数会阻塞，waitpid()可以设置不阻塞，waitpid()还可以指定等待哪个子进程结束。

​	注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程使用循环。



#### 16.2 wait函数

函数说明:

```
#include <sys/types.h>
#include <sys/wait.h> 

pid_t wait(int * status);
功能：
	等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收改子进程的资源
参数：
	status：进程退出时的状态信息
返回值：
	成功：已经结束子进程的进程号
	失败：-1
```

wait函数为阻塞该进程并等待任意进程结束

多个子进程情况下不能指定进程



宏函数处理status

1) WIFEXITED(status)

   ​	为非0 -> 进程正常结束

   WEXITSTATUS(status)

   ​	如为真，使用此宏 -> 获取进程退出状态

2) WIFSIGNALED(status)

   ​	为非0 -> 进程异常终止

   WTERMSIG(status)

   ​	宏为真，使用此宏 -> 获取使进程终止的那个信号的编号

3) WIFSTOPPED(status)

   ​	为非0 -> 进程处于暂停状态

   WSTOPSIG(status)

   ​	为真，使用此宏 -> 获取使进程暂停的那个信号的编号。

   WIFCONTINUED(status)

   ​	为真 -> 进程暂停后已经继续运行



#### 16.3 waitpid函数

```
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int* status,int option);
功能：
	等待子进程终止，如果子进程终止了，此函数会回收子进程的资源
	
参数：
	pid：参数pid的值有以下几种类型
		pid > 0 等待进程等于pid的子进程
		pid = 0等待同一个进程组中的任意子进程，如果子进程已经加入了别的进程组，waitpid不会等待它。
		pid = -1 等待任意子进程，此时waitpid和wait作用一样
		pid < -1 等待指定进程组中的任意子进程，这个进程组的ID等于pid的的绝对值
		
	status：进程退出的状态信息。和wait()用法一样。
		
	options：options提供了一些额外的选项来控制waitpid()。
		0:同wait()，阻塞父进程，等待子进程退出
		WNOHANG:没有任何已经结束的子进程，则立即返回。
		WUNTRACED: 如果子进程暂停了则此函数马上返回，并且不予以理会子进程的结束状态。（由于涉及到一些跟踪调试方面的知识，加之极少用到）
返回值：
	waitpid()的返回值比wait稍微复杂一些，一共有3种情况：
		1）当正常返回的时候waitpid()返回收集到的已经回收的子进程的进程号
		2）如果设置了选项 WNOHANG，而调用中waitpid()发现没有已退出的子进程可等待，则返回0
		3）如果调用中出错，则返回-1，这时errno会被设置成相应的值以指示错误所在，如：当pid所对应的子进程不存在，或者此进程存在，但不是调用进程的子进程，waitpid()就会出错返回，这时errno被设置为ECHILD
```



### 17. 孤儿进程

​	父进程运行结束，但子进程还在运行（未运行结束）的子进程就称为孤儿进程



​	每当出现一个孤儿进程时，内核就把孤儿进程的父进程设置为init，而init进程会循环的wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会处理它的一切善后工作。

​	因此孤儿进程并不会有什么危害。



### 18.僵尸进程

​	进程终止，父进程尚未回收，子进程残留资源（PCB），变成僵尸（zombie）进程。

​	这样就会导致一个问题，如果进程不调用wait()或者waitpid()的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号，而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。



子进程结束但父进程未结束或被强行终止时会出现 



### 19. execlp进程替换

如何在进程内部启动一个外部的进程，由内核将这个外部程序读入内存，使其执行起来成为一个进程呢？这里我们通过exec函数族实现。

exec函数族，顾名思义，就是一簇函数，在linux中，并不存在exec()函数，exec指的是一组函数，一共有6个。

```
#include <unistd.h>
extern char** environ;

int execl(const char* path, const char* arg, .../*(char*) NULL */);
int execlp(const char* file, const char* arg,.../*(char*) NULL */);
int execle(const char* path, const char* arg,.../*(char*) NULL ，char* const envp[]*/);
int execv(const char* path, char* const argv[]);
int execvp(const char* file, char* const argv[]);
int execvpe(const char* file, char* const argc[], char* const envp[]);
int execve(const char* filename,char* const argc[],char* envp[]);


```

（若要执行自己的程序 则第一个参数的路径必须要写完整 否则找不到**除非将文件放到path路径中**）

exec族没返回值来判断成功与否但可直接接上perror()

**记忆方法：**

exec +		 l / v  				+		  p		+				e

​		链式list/数组vector		  路径path		环境变量environ

程序例：

```
char* argv[] = { "ls", "-l", "/home", NULL};
char* envp[] = { "ADDR = BEIJING", NULL};
execve("ls",argv,envp[]); 
```

**注:使用execvpe时必须加一个宏：_GNU_SOURCE**
