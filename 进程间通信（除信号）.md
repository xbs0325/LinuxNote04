# 进程间通信(除信号)

[TOC]

## 1. 无名管道

 ### 1.1 概述

​	管道也叫无名管道，它是UNIX系统IPC（进程间通信）的最古老的形式，所有的UNIX系统都支持这种通信机制。

**管道有如下特点**

1） 半双工

2） 数据只能从管道的一端写入，从另一端读出

3） 写入管道的数据遵循先入先出的规则

4） 管道所传送的数据是无格式的，这要求管道的读出方与写入方必须事先约定好数据的格式，如多少个字节算一个消息等

5） 管道不是普通的文件，不属于某个文件系统，其只存在于内存中。

6） 管道在内存中对应一个缓存区。不同的系统其大小不一定相同。

7）从管道读数据是一次性操作，数据一旦被读走，他就从管道中被抛弃，释放空间以便写更多的数据。

8）管道没有名字，只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。

对于管道特点的理解，我们可以类比现实生活中的管子，管子一端塞东西，管子的另一端取东西。

管道是一种特殊类型的文件，在应用层体现为两个打开的文件描述符。

### 1.2 pipe函数

```
#include <unistd.h>
int pipe(int pipefd[2]);
功能: 创建无名管道

参数: 
	pipefd: 为int类型数组的地址，其存放了管道的文件描述符pipefd[0],pipefd[1]
	
	当一个管道建立时，他会创建两个文件描述符fd[0]和fd[1],其中fd[0]固定用于读管道，而fd[1]固定用于写管道。一般文件I/O的函数都可以用来操作管道（lseek除外）。

返回值: 
	成功:0
	失败:-1
```

### 1.3 管道读写特性

**四种情况:**

​	**第一种:**

​				如果写端没有关闭，管道中没有数据，这时候读管道进程读管道会堵塞

​				如果写端没有关闭，管道中有数据，这个时候管道进程会将数据读出，下一次读没有数据就会阻塞。	

​	**第二种:**

​				管道所有的写端关闭，读进程去读管道的内容，读取全部内容，最后返回0

​	**第三种:**

​				所有读端没有关闭，如果管道被写满了，写管道进程写管道会阻塞（4kb时候管道满）		

​	**第四种:**

​				所有的读端被关闭，写管道进程写管道会收到一个信号，然后退出



### 1.4 设置为非阻塞的方法

例：读管道设为非阻塞

```
flags = fcntl(fd[0],F_GETFL);
flags |= O_NONBLOCK;
fcntl(fd[0],F_SETFL,flags);
```



### 1.5 查看缓冲区大小

```
#include <unistd.h>

long fpathconf(int fd,int name);
功能: 该函数可以通过name参数查看不同的属性值
参数:
	fd: 文件描述符
	name:
		_PC_PIPE_BUF, 查看管道缓冲区的大小
		_PC_NAME_MAX, 文件名字字节数的上限
返回值:
	成功: 根据name的返回值意义也不同
	失败: -1
```





## 2. 有名管道

### 2.1 概述

​	管道,由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了命名管道(FIFO)，也就叫有名管道、FIFO文件。

命名管道(FIFO)不同于无名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，这样，即使与FIFO的创建进程不存在血缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信，因此，通过FIFO不相关的进程也能交换数据。



命名管道(FIFO)和无名管道(pipe)有一些特点是相同的，不一样的地方在于:

1) FIFO在文件系统中作为一个特殊的文件而存在，但FIFO中的内容却存放在内存中。
2) 当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用。
3) FIFO有名字，不相关的进程可以通过打开命名管道进行通信

### 2.2 通过命名创建有名管道

``` 
mkfifo fifo

ls -l fifo //查看fifo
```



### 2.3 通过函数创建有名管道

```
#include <sys/types.h>
#include <sys/stat.h>

int mkfifo(const char * pathname, mode_t mode);
功能:
	命名管道的创建
参数:
	pathname: 普通的路径名，也就是创建后的FIFO的名字
	mode: 文件的权限，与打开普通文件的open()函数中的mode参数相同。
返回值:
	成功: 0 状态码
	失败: 如果文件已经存在，则会出错返回-1
```

### 2.4 有名管道的读写操作

​	一旦使用mkfifo就可以open打开它，常见的文件I/O函数都可用于fifo。如: close、read、write、unlink等。

​	FIFO严格遵循先进先出(first in first out)，对管道及FIFO的读总是从开始处返回数据，对他们的写则把数据添加到末尾。他们不支持诸如lseek()等文件定位操作

### 2.5 有名管道注意事项

1） 一个为只读而打开一个管道的进程会阻塞直到另外一个进程为只写打开该管道

2） 相反同理

#### 读管道

* 管道中有数据，read返回实际读到的字节数。
* 管道中无数据：
  * u管道写端被全部关闭，read返回0（相当于读到文件末尾）
  * u写端没有全部关闭，read阻塞等待



#### 写管道

* 管道读端全部被关闭，进程异常终止（也可以使用SIGPIPE信号，使进程终止）
* 管道读端没有全部关闭：
  * u管道已满，write阻塞。
  * u管道未满，write将数据写入，并返回实际写入的字节数。

## 3. 共享存储映射

### 3.1 概述

存储映射 使磁盘空间与储存空间中的一个缓冲区相映射

(硬盘内容映射到内存中)

​	可以不使用write read而是使用指针完成I/O操作

​	共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式，因为进程可以直接读写内存，而不需要任何数据的拷贝。



### 3.2 存储映射函数

(1) mmap函数 (memory map 内存映射)

(mman指memory manage)

```
#include <sys/mman.h>

void* mmp(void* addr, size_t length, int prot, int flags, int fd, off_t offset);
功能：
	一个文件或者其他对象映射进内存
参数：
	addr: 指定映射的起始地址，通常设为NULL,由系统指定
	length: 映射到内存的文件长度
	prot: 映射区的保护方式，最常用的:
		a) 读: PROT_READ
		b) 写: PROT_WRITE
		c) 读写: PROT_READ | PROT_WRITE
	flags: 映射区的特性，可以是
		a) MAP_SHARED: 写入映射区的数据会复制回文件，且允许其他映射该文件的进程共享。
		b)MAP_PRIVATE: 对映射区的写入操作会产生一个映射区的复制(copy - on - write),对此区域所做的修改不会写回源文件。
	fd: 由open返回的文件描述符，代表要映射的文件
	offset: 以文件开始处的偏移量，必须是4K的整数倍，通常为0，表示文件从头开始映射
返回值:
	成功: 返回创建的映射区首地址
	失败: MAP_FAILED宏
		
```

**使用总结**

1)第一个参数写成NULL

2)第二个参数要映射的文件大小>0

3)第三个参数:PROT_READ PROT_WRITE

4)第四个参数:MAP_SHARED或者MAP_PRIVATE

5)第五个参数:打开的文件对应的文件描述符

6)第六个参数:4k的整数倍，通常为0



(2)munmap函数

```
#include <sys/mman.h>

int munmap(void* addr, size_t length);
功能:
	释放内存映射区
残数:
	addr: 使用mmap函数创建的映射区首地址
	length: 映射区的大小
返回值:
	成功: 0
	失败: -1
```



### 3.3 注意事项

1) 创建映射区的过程中，隐含着一次对映射文件的读取操作
2) 当MAP_SHARED时，要求：映射区的权限<=文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。
3) 映射区的注释与文件关闭无关。只要映射建立成功，立即可以关闭
4) 特别注意，当映射文件大小为0时，布恩那个创建映射区。所以，用于映射的文件必须要有实际的大小。mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的
5) munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作。
6) 如果文件偏移量必须为4K的整数倍
7) mmap创建映射区的出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作



### 3.4 共享映射的方式操作文件

```
int fd = -1;
int ret = -1;
void* addr = NULL;

//1.以读写的方式打开一个文件
fd = open("txt",O_RDWR);
if(-1 == fd)
{	
	perror("open");
	return 1;
}

//2.将文件映射到内存
addr = mmap(NULL,1024,PROT_READ | PROT_WRITE,MAP_SHARED, fd, 0);
if(addr == MAP_FAILED)
{
	perror("mmap");
	return 1;
}
printf("文件储映射ok...\n");

//3.关闭文件
close(fd);

//写文件
memcpy(addr,"0123456789",10);

//断开连接
munmap(addr,1024);

return 0;
```



### 3.5 共享映射实现父子进程通信

```
//打开文件

//创建内存映射区

//关闭文件

//创建子进程

//子写 父等待 父读

```



### 3.6 匿名映射实现父子进程通信

​	通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也比较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。

​	通常是为了建立映射区open一个temp文件，创建好了再unlink，close掉，比较麻烦，可以直接使用匿名映射来代替

​	其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。

使用MAP_ANONYMOUS（或MAP_ANON）

`int *p = mmap(NULL,1024,PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);`

* MAP_ANONYMOUS和MAP_ANONY这两个宏是Linux操作系统特有的宏。再类UNIX系统中无该宏定义，可使用如下两步来完成匿名映射区的建立。



