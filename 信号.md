[TOC]

# 信号

## 1.信号的概述

**信号的概念**

​	信号是Linux进程间通信的最古老的方式。信号是软件中断，他是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程终端，转而处理某一个突发事件。

​	“中断”在我们生活中经常遇到，譬如，我们正在房间里打游戏，突然快递送来了，把正在玩游戏的我给“中断”了，我去签收快递（处理中断），处理完成后，再继续玩我的游戏。

​	这里我们学习的“信号“就属于这么一种”中断“。我们在终端上敲"Ctrl+c",就产生了一个”中断“，相当于产生一个信号，接着就会处理这么一个”中断任务“（默认的处理方式为中断当前进程）

 **信号的特点**

* 简单
* 不能携带大量信息
* 满足某个特设条件才发送  

​	信号可以直接进行用户空间和内核空间进程的交互，内核进程可以利用它来通知用户空间进程发生了哪些系统事件。

​	一个完整的信号周期包括三个部分：信号的产生，信号在进程中的注册，信号在进程中的注销，执行信号处理函数，如下图所示：

​	![](.\信号周期三个部分.png)

注意: 这里信号的产生，注册，注销时信号的内部机制，而不是信号的函数实现

## 2. 信号的编号

### 2.1 信号编号

​	Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley和AT&T都对信号模型做了更改，增加了可靠信号的机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。

​	Linux可使用指令：kill -l , 查看相应的信号

​	不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），曾经32 33有问题隐藏了，34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同

### 2.2 Linux常规信号一览表

| 编号  | 信号                          | 对应事件                                                     | 默认动作                   |
| ----- | ----------------------------- | ------------------------------------------------------------ | -------------------------- |
| 1     | SIGHUP                        | 用户退出shell时，由该shell启动的所有进程将收到这个信号       | 终止进程                   |
| 2     | SIGINT                        | 当用户按下了<Ctrl+C>组合键时，用户端向正在运行中的由该终端启动的程序发出此信号 | 终止进程                   |
| 3     | SIGQUIT                       | 用户按下<Ctrl+\\>组合键时产生该信号，用户端向正在运行中的由该终端启动的程序发出些信号 | 终止进程                   |
| 4     | SIGILL                        | CPU检测到某进程执行了非法指令                                | 终止进程并产生core文件     |
| 5     | SIGTRAP                       | 该信号由断点指令或其他trap指令产生                           | 终止进程并产生core文件     |
| 6     | SIGABRT                       | 调用abort函数时产生该信号                                    | 终止进程并产生core文件     |
| 7     | SIGBUS                        | 非法访问内存地址，包括内存对齐出错                           | 终止进程并产生core文件     |
| 8     | SIGPE                         | 在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误 | 终止进程并产生core文件     |
| 9     | SIGKILL                       | 无条件终止进程。本信号不能被忽略，处理和阻塞                 | 终止进程，可以杀死任何进程 |
| 10    | SIGUSE1                       | 用户定义的信号。即程序员可以在程序中定义并使用该符号         | 终止进程                   |
| 11    | SIGSEGV                       | 指示进程进行了无效的内存访问（段错误）                       | 终止进程并产生core文件     |
| 12    | SIGUSR2                       | 另外一个用户自定义的信号，程序员可以在程序中定义并使用该信号 | 终止进程                   |
| 13    | SIGPIPE                       | Broken pipe向一个没有读端的管道写数据                        | 终止进程                   |
| 14    | SIGALRM                       | 定时器超时，超时的时间由系统调用alarm设置                    | 终止进程                   |
| 15    | SIGTERM                       | 程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要表示程序正常退出。执行shell命令kill时，缺省产生这个信号 | 终止进程                   |
| 16    | SIGSTKFLK                     | Linux早期版本出现的信号，现仍保留向后兼容                    | 终止进程                   |
| 17    | SIGCHLD                       | 子进程结束时，父进程会收到这个信号                           | 忽略这个信号               |
| 18    | SIGCONT                       | 如果进程已终止，则使其继续运行                               | 继续/忽略                  |
| 19    | SIGSTOP                       | 停止进程的执行。信号不能被忽略，处理和阻塞                   | 为终止进程                 |
| 20    | SIGSTP                        | 停止终端交互进程的运行。按下<ctrl+z>组合键时发出这个信号     | 暂停进程                   |
| 21    | SIGTTIN                       | 后台进程读终端控制台                                         | 暂停进程                   |
| 22    | SIGTTOU                       | 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生        | 暂停进程                   |
| 23    | SIGURG                        | 套接字上有紧急数据时，向当前正在运行的进程发出信号，报告有紧急数据到达。如网络带外数据到达 | 忽略该信号                 |
| 24    | SIGXCPU                       | 进程执行时间超过了分配给该进程的CPU时间，系统产生该信号并发送给该进程 | 终止进程                   |
| 25    | SIGXFSZ                       | 超过文件的最长长度                                           | 终止进程                   |
| 26    | SIGVTALRM                     | 虚拟时钟超市时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的时间 | 终止进程                   |
| 27    | SIGPROF                       | 类似于SIGVTALRM，他不仅包括该进程占用CPU的时间该包括执行系统调用的时间 | 终止进程                   |
| 28    | SIGWINCH                      | 窗口变化大小时发出                                           | 忽略该信号                 |
| 29    | SIGIO                         | 此事件向进程指示发出了一个异步IO事件                         | 忽略该信号                 |
| 30    | SIGPWR                        | 关机                                                         | 终止进程                   |
| 31    | SIGSYS                        | 无效的系统调用                                               | 终止进程并产生core文件     |
| 34-64 | SIGRTMIN<br />~<br />SIGRTMAX | Linux的实时信号，他们没有固定的含义（可以由用户定义）        | 终止进程                   |

## 3. 信号四要素

每个信号必备四要素，分别是

1）编号 2）名称 3）事件 4）默认处理动作

可通过man 7 signal查看帮助文档获取

Signal Value Action Comment

​	在标准信号中，有一些信号是有三个“Value”，第一个值通常对alpha和sparc构架有效，中间值对x86 arm和其他架构，最后一个应用于mips构架。一个‘-’表示在对应架构上尚未定义该信号。

​	不同的操作系统定义了不用的系统信号。因此有些信号出现在Unix系统中，也出现在Linux中，而有的信号出现在FreeBSD和Mac OS中却没有出现在Linux下。这里我们只研究Linux系统中的信号



Action为默认动作：

* Term：终止进程
* Ign：忽略信号（默认即使对这种信号忽略操作）
* Core：终止进程，生成Core文件。（查验死亡原因，用于gdb调试）
* Stop：停止（暂停）进程
* Cont：继续运行进程
* 注意通过man 7 signal命令查看帮助文档，其中可看到：The signals **SIGKILL** and **SIGSTOP** cannot be caught，blocked ，or ignored
  * 这里特别强调了**9) SIGKILL和 19）SIGSTOP信号，需允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。**
  * 另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送（但不一定递达），不应乱发信号！！

## 4. 信号的状态

### 4.1 产生

**用户操作 硬件 软件 调用系统函数 运行kill**

a) 当用户按某些终端键时，将产生信号。

​	终端上按“Ctrl+c”组合键通常产生中断信号SIGINT

​	终端上按“Ctrl+\”通常产生中断信号SIGQUIT

​	终端上按“Ctrl+z”通常产生中断信号SIGSTOP等。

b)硬件异常将产生信号

​	除数为0，无效的内存访问等。这些情况通常由硬件检测到，并通知内核，然后内核产生适当的信号发送给相应的进程。

c)软件异常将产生信号

​	当检测到某种软件条件已发生（如: 定时器alarm），并通知有关进程时，产生信号

d)调用系统函数（如：kill，raise，abort）将发送信号。

​	注意：接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。

e) 运行 kill /killall命令将发送信号。

此程序实际上是使用kill函数来发送信号。也常用此命令中止上一个失控的后台进程

### 4.2 未决状态：

没有被处理

### 4.3 递达状态：

信号被处理了

## 5. 阻塞信号集和未决信号集

​	信号的实现手段导致信号有很强的延时性，但对用户来说不易察觉

Linux内核的进程控制块PCB中除了进程id 状态等等内容包含了进程相关的信息，主要指**阻塞信号集和未决信号集**。

相当于黑名单 和 未读信息



## 6.信号产生函数

### 6.1 kill函数

```
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid,int sig);
功能:
	给指定的进程发送指定信号（不一定杀死）
参数:
	pid: 取值有四种情况:
		pid > 0 将信号传送给进程ID为pid的进程
		pid = 0	将信号传送给当前进程所在进程组
		pid = -1 将信号传送给系统内所有的进程。
		pid < -1 将信号传给指定进程组的所有进程。这个进程组号等于pid的绝对值
		sig: 信号的编号，这里可以填数字编号，也可以填信号的宏定义（推荐使用宏定义 不用操作系统编号可能不同 但名称一致）
		
返回值:
	成功: 0
	失败: -1
```

​	root用户可以发送信号给任意用户，普通用户不能向系统用户发送信号

​	kill -9（root用户的pid）是不可以的。普通用户也不能给其他普通用户发送信号，只能向自己创建的进程发送信号。

​	普通用户基本规则是：发送者实际或者有效用户ID == 接收者实际或有效用户ID	

### 6.2 raise函数

```
#include <signal.h>

int raise(int sig);
功能: 给当前进程发送指定信号（自己给自己发），等价于kill(getpid(),sig)
参数:
	sig:信号编号
返回值:
	成功: 0
	失败: 非0值
```



### 6.3 abort函数

```
#include <stdlib.h>

void abort(void);
功能:
	给自己发一个异常终止的信号 6）SIGABRT,并产生core文件，等价于kill(getpid(),SIGABRT);
参数:
	无
返回值:
	无
```



### 6.4 alarm函数

```
#include <unistd.h>

unsigned int alarm(unsigned int seconds);
功能:
	设定定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作取消，每个进程都有且只有唯一的一个定时器。
	取消定时器alarm(0),返回旧闹钟余下秒数。
参数:
	seconds:指定的时间，以秒为单位
返回值:
	返回0或上次调用alarm时剩余的秒数
```



### 6.5 setitimer函数

```
#include <sys/time.h>

int setitimer(int which, const struct itimerval * new_value,struct itimerval* old_value);
功能:
	设定定时器(闹钟).可代替alarm函数。精度微妙us，可以实现周期定时。
参数:
	which: 指定定时方式
		a) 自然定时: ITIMER_REAL -> 14)SIGALRM计算自然时间
		b)虚拟空间计时(用户控件):ITIMER_VIRTUAL->26)SIGVTALRM 只计算进程占用cpu的时间
		c)运行新计时(用户 + 内核):ITIMER_PROF->27)SIGPROT计算占用cpu及执行系统调用的时间			new_value:struct itimerval,负责设定timeout的时间
		struct itimerval{
			struct timerval it_interval;//闹钟触发周期
			struct timerval it_value; //闹钟触发时间
		};
		sturct timeval{
			long tv_sec; //秒
			long tv_usec; //微秒
		};
		itimerval.it_value: 设定第一次执行function所延迟的秒数
		itimerval.it_interval;谁当以后每几秒执行function
	old_value: 存放旧的timeout值，一般指定为NULL
返回值:
	成功: 0
	失败: -1
		
```



## 7. 信号集

 ### 7.1 信号集概述

​	在PCB中有两个非常重要的信号集。一个称之为“信号阻塞集”，另一个称之为“未决信号集”。

这两个信号集都是内核使用**位图机制**来实现的。但操作系统不允许我们直接进行位操作。而需自定义另外一个集合，借助信号集操作函数来对PCB的这两个信号进行修改

![](.\信号集.png)

## 8. 信号捕捉

### 8.1 signal函数

```
#include <signal.h>

typedef void* (*sighandler_t)(int);
sighanle_t signal(int signum, sighandler_t handler)
功能:
	注册信号处理函数（不可用于SIGKILL、SIGSTOP信号），即确定收到信号后处理函数的入口地址。此函数不会阻塞。
	
参数:
	signum: 信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令kill -l("l" 为字母)进行相应查看。
	handle: 取值有三种情况:
		SIG_IGN: 忽略该信号
		SIG_DFL: 执行系统默认动作
		信号处理函数名:自定义信号处理函数，如：func
		回调函数的定义如下:
			void func(int signo)
			{
				//signo为触发的信号，为signal（）第一个参数的值
			}
返回值:
	成功: 第一次返回NULL，下一次返回此信号上一次注册的信号处理函数的地址，如果需要使用此返回值，必须在前面先声明此函数指针的类型。
	失败: 返回SIG_ERR
```

该函数由ANSI定义，由于历史原因在不同的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。

**(写代码时的发现)**

在一般情况下，SIGQUIT信号是可以唤醒处于睡眠状态的进程的。SIGQUIT信号的默认行为是终止进程，并在终止时生成一个核心转储（core dump）。

然而，需要注意的是，如果一个进程已经被操作系统挂起（suspended），那么在这种情况下发送SIGQUIT信号可能不会起作用，因为挂起的进程已经被暂停了。
